import fs from "node:fs";
import path from "node:path";

const ROUTE_TREE_PATH = path.join(process.cwd(), "src/routeTree.gen.ts");
const OUTPUT_PATH = path.join(
  process.cwd(),
  "src/lib/hono/path-manifest.generated.ts",
);

function generate() {
  // 检查文件是否存在
  if (!fs.existsSync(ROUTE_TREE_PATH)) {
    console.error(`Error: Route tree not found at ${ROUTE_TREE_PATH}`);
    process.exit(1);
  }

  const content = fs.readFileSync(ROUTE_TREE_PATH, "utf-8");

  // 1. 提取路径
  const match = content.match(/fullPaths:\s*([\s\S]*?)(?=\s*fileRoutesByTo:)/);
  if (!match) {
    console.error("Could not find fullPaths in routeTree.gen.ts");
    process.exit(1);
  }

  const pathsBlock = match[1];

  // 2. 清洗数据 & 去重
  const rawPaths = pathsBlock
    .split("|")
    .map((p) => p.trim().replace(/['"]/g, ""))
    .filter((p) => p.length > 0);

  const uniquePaths = Array.from(
    new Set(rawPaths.map((p) => (p === "/" ? "/" : p.replace(/\/$/, "")))),
  );

  // 3. 构建正则表达式代码字符串
  const regexDefinitions = uniquePaths.map((p) => {
    let patternStr = "";

    if (p === "/") {
      patternStr = "^/$";
    } else {
      // a. 转义正则特殊字符 (robots.txt -> robots\.txt)
      // 这里的 \ 在脚本内存中是单个反斜杠
      let pattern = p.replace(/[.*+?^()|[\]\\]/g, "\\$&");

      // b. 处理参数 $slug -> [^/]+
      pattern = pattern.replace(/\$[^/]+/g, "[^/]+");

      // c. 拼接起止符
      patternStr = `^${pattern}/?$`;
    }

    // 【关键修复】：使用 JSON.stringify 自动生成带双引号且正确转义的字符串字面量
    // 比如：内存里的 ^robots\.txt/?$ -> 变成源码字符串 "^robots\\.txt/?$"
    return `new RegExp(${JSON.stringify(patternStr)})`;
  });

  // 4. 生成最终文件内容
  // 【关键修复】：RegExp[] -> Array<RegExp>
  const outputContent = `// Automatically generated by scripts/generate-manifest.ts
// Do not edit this file manually.

// Pre-compiled Regexes for maximum performance on Cloudflare Workers
export const ROUTE_REGEXPS: Array<RegExp> = [
  ${regexDefinitions.join(",\n  ")},
];

/**
 * Checks if the path matches any valid route.
 * O(n) regex checks, but zero compilation overhead at runtime.
 */
export function isPathValid(path: string): boolean {
  return ROUTE_REGEXPS.some((regex) => regex.test(path));
}
`;

  fs.writeFileSync(OUTPUT_PATH, outputContent);
  console.log(
    `✅ Generated manifest with ${regexDefinitions.length} compiled regexes to ${OUTPUT_PATH}`,
  );
}

generate();
